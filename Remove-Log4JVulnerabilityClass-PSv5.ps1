Clear-Host


FUNCTION Remove-Log4JVulnerabilityClass {
<#
.SYNOPSIS
CleanUp script for removing vulnerable Java class based on CVE-2021-45105

.DESCRIPTION
As the last resorse, the removing of the class file "JndiLookup.class" from the jar file containing it, can be necessary
This script can find all jar files, or a single specified file,  with the vulnerability and remove it.
You can also choose just to get a list of files that contains the class.

.PARAMETER file
fullname of a single file to investigate

.PARAMETER JavaClass
The class name to remove

.PARAMETER WorkFolder
The folder to where the work on the file is done
Default: "temp-log4j"

.PARAMETER RootPath
The drive the workfolder is created on
Default: "C:""

.PARAMETER Compressionlevel
What type of compression should be used
Default: "Fastest"

.PARAMETER includeNetworkShare
Switch parameter to choose to query only local or all mapped drives
If used it will query both local drives, and remote smbmapped drives

.PARAMETER Out
To get the result of the cleanup out as an Object

.PARAMETER onlyQuery
If only interesting in getting the numbers, and fullnames on files vulnerable


.EXAMPLE
Remove-UDFLog4JVulnerabilityString -file "D:\ZIP\PAD.JavaBridge.jar" -out -onlyQuery -verbose

VERBOSE: 00:29:47.2647 [QUERING        ] file [D:\ZIP\PAD.JavaBridge.jar]
VERBOSE: 00:29:47.3357 [QUERING        ] files found [1]


FileName     : 
FullName     : D:\ZIP\PAD.JavaBridge.jar
Cleaned      : False
Action       : onlyQeury
ComputerName : COMPUTER01
QueryDate    : 19-12-2021 00:29:47



.EXAMPLE
Remove-UDFLog4JVulnerabilityString -out -onlyQuery -verbose


VERBOSE: 00:28:08.4418 [QUERING        ] Looking on all drives
VERBOSE: 00:28:40.8502 [QUERING        ] files found [4]

FileName     : 
FullName     : D:\PowerAutomate\2.14.173.21294\PAD.JavaBridge.jar | D:\PowerAutomate\2.15.282.21349\PAD.JavaBridge.jar | D:\ZIP\PAD.JavaBridge-2.jar | D:\ZIP\PAD.JavaBridge.jar
Cleaned      : False
Action       : onlyQeury
ComputerName : COMPUTER01
QueryDate    : 19-12-2021 00:28:40


.EXAMPLE
Remove-UDFLog4JVulnerabilityString -file "D:\ZIP\PAD.JavaBridge.jar"  -Verbose -out

VERBOSE: 01:31:31.9172 [QUERING        ] file [D:\ZIP\PAD.JavaBridge.jar]
VERBOSE: 01:31:32.0002 [QUERING        ] files found [1]
VERBOSE: 01:31:32.0022 [DIRECTORY      ] creating folder [D:\_temp-log4J]
VERBOSE: 01:31:32.0032 [DIRECTORY      ] creating folder [D:\_temp-log4J\ZIP]
VERBOSE: 01:31:32.0042 [FILENAME       ] D:\ZIP\PAD.JavaBridge.jar
VERBOSE: 01:31:32.0042 [COPY/RENAME    ] [D:\ZIP\PAD.JavaBridge.jar] to [D:\_temp-log4J\PAD.JavaBridge.zip]
VERBOSE: 01:31:32.0163 [EXPAND         ] [D:\_temp-log4J\PAD.JavaBridge.zip] to folder [D:\_temp-log4J\ZIP]
VERBOSE: 01:31:47.0979 [REMOVING CLASS ] [D:\_temp-log4J\ZIP\org\apache\logging\log4j\core\lookup\JndiLookup.class] class [JndiLookup.class]
VERBOSE: 01:31:47.1009 [COMPRESS       ] [D:\_temp-log4J\ZIP] to [D:\_temp-log4J\PAD.JavaBridge.zip]
VERBOSE: 01:32:00.8900 [COPY/RENAME    ] [D:\_temp-log4J\PAD.JavaBridge.zip] to [D:\ZIP\PAD.JavaBridge.jar]
VERBOSE: 01:32:00.8990 [CLEANUP        ] removing folder [D:\_temp-log4J]
VERBOSE: 01:32:00.9000 [CLEANUP        ] status [Successful]
VERBOSE: 01:32:00.9910 [FILEMAME       ] [D:\ZIP\PAD.JavaBridge.jar] status [CLEANED]


FileName     : PAD.JavaBridge.jar
FullName     : D:\ZIP\PAD.JavaBridge.jar
Cleaned      : True
Action       : Clean
ComputerName : COMPUTER01
QueryDate    : 19-12-2021 01:32:00


.EXAMPLE
Remove-UDFLog4JVulnerabilityString -file "D:\ZIP\PAD.JavaBridge.jar"  -Verbose -out

VERBOSE: 01:32:03.5076 [QUERING        ] file [D:\ZIP\PAD.JavaBridge.jar]
VERBOSE: 01:32:03.5946 [QUERING        ] files found [0]

FileName     :
FullName     :
Cleaned      : True
Action       : Clean
ComputerName : COMPUTER01
QueryDate    : 19-12-2021 01:32:03


.EXAMPLE
Remove-Log4JVulnerabilityClass -Verbose -onlyQuery -out -includeNetworkShare
VERBOSE: 11:34:04.2862 [QUERING        ] Looking on [all] drives
VERBOSE: 11:34:32.5042 [QUERING        ] files found [2]

FileName     : 
FullName     : C:\LOG4J\FILES\PAD.JavaBridge-2.jar | Z:\FILES\PAD.JavaBridge-2.jar
Cleaned      : False
Action       : onlyQeury
ComputerName : COMPUTER01
QueryDate    : 12/21/2021 11:34:32 AM


.EXAMPLE
> Remove-Log4JVulnerabilityClass -Verbose -onlyQuery -out
VERBOSE: 11:34:40.5043 [QUERING        ] Looking on [local] drives
VERBOSE: 11:35:08.4573 [QUERING        ] files found [1]

FileName     : 
FullName     : C:\LOG4J\FILES\PAD.JavaBridge-2.jar
Cleaned      : False
Action       : onlyQeury
ComputerName : COMPUTER01
QueryDate    : 12/21/2021 11:35:08 AM

.NOTES

AUTHOR:     Aksel Bork
Date:       2021-12-19
PSVersio:   5
Version:    2021-12-19  1       Creation
            2021-12-21  1.1     Adding the option to filter out SMBMapped shares. For making the query local, and not having the same file showing up on each computer, 
                                that have the same share added.
                                The default is "local" only

.LINK
https://github.com/akselbork/Remove-Log4JVulnerabilityClass-/edit/main/Remove-Log4JVulnerabilityClass-PSv5.ps1


#>
    [cmdletbinding()]
    Param (    
        [parameter()]
        [ValidateScript({
            if(-Not ($_ | Test-Path) ){
                throw "File or folder does not exist"
            }
            if(-Not ($_ | Test-Path -PathType Leaf) ){
                throw "The Path argument must be a file. Folder paths are not allowed."
            }
            if($_ -notmatch "(\.jar)"){
                throw "The file specified in the path argument must be Jar"
            }
            return $true 
        })]
        [System.IO.FileInfo]$file,  # = "D:\ZIP\PAD.JavaBridge2.jar" ,

        [string]$JavaClass          = "JndiLookup.class",

        [string]$WorkFolder         = "_temp-log4J",

        [string]$RootPath           = "C:",

        [string]$CompressionLevel   = "Fastest", 

        [SWITCH]$includeNetworkShare,

        [SWITCH]$out,

        [SWITCH]$onlyQuery
    )
    BEGIN {
        #region HELPERFUNCTIONS
        FUNCTION WV {
            Param (
                $prefix,
                $message
            )
            $time = Get-Date -f HH:mm:ss.ffff
            Write-Verbose "$time [$($prefix.padright(15,' '))] $message"
        }
        #endregion 
        [array]$sourceFiles = $null
        $WorkFolderPath     = Join-Path $RootPath $WorkFolder
        $output             = $null

        IF (-NOT ($PSBoundParameters.ContainsKey('File'))) {
            ## FIND JAR-FILES 
            IF ($includeNetworkShare.IsPresent) {
                WV -prefix QUERING -message "Looking on [all] drives"
                $smbMapping = $null
            } ELSE {
                 WV -prefix QUERING -message "Looking on [local] drives"
                 TRY {
                    $smbMapping = Get-SmbMapping -ErrorAction SilentlyContinue
                } CATCH {
                    WV -prefix QUERING -message "Could not find any [MAPPED] drives"
                    $smbMapping = $null
                }
            }
            IF ($includeNetworkShare.IsPresent) {
                $Drives = Get-PSDrive | Where-Object {($_.provider -like "*FileSystem*")}
            } ELSE {
                $Drives = Get-PSDrive | Where-Object {($_.provider -like "*FileSystem*") -and ($_.DisplayRoot -notin $smbMapping.remotepath)}
            }

            $sourceFiles = $Drives| foreach {
                Get-ChildItem $_.root -Recurse -Filter "*.jar" -force -ErrorAction SilentlyContinue | foreach {
                    TRY {
                        Select-String $_ -pattern $JavaClass -ErrorAction Stop | Select-Object path -Unique -ErrorAction SilentlyContinue
                    } CATCH {
                    }
                }
            }

        } ELSE {
            WV -prefix QUERING -message "file [$file]"
            $sourceFiles = get-item $file 
            
            $sourceFiles | foreach {
                TRY {
                    Select-String $_ -pattern $JavaClass -ErrorAction Stop | Select-Object path -Unique -ErrorAction SilentlyContinue
                } CATCH {
                }
            }
        }
        WV -prefix QUERING -message "files found [$($sourcefiles | measure-object | select-object -ExpandProperty count)]"
    }
    PROCESS {
        ## REMOVE "JndiLookup" CLASS FROM JAR FILES AND COMPRESS THEM AGAIN
        IF ((($sourceFiles | Measure-Object).count -gt 0) -and ($onlyQuery.IsPresent -eq $false)) { 
            TRY {
                WV -prefix DIRECTORY -message "creating folder [$WorkfolderPath]"
                New-Item -Name $WorkFolder -path $RootPath -ItemType Directory -Force -ErrorAction SilentlyContinue | Out-Null
                
            } CATCH {
            }
            IF (Test-Path $WorkFolderPath ) {
                $ZIPfolderPath = (Join-Path $WorkFolderPath ZIP)
                TRY {
                    WV -prefix DIRECTORY -message "creating folder [$ZipfolderPath]"
                    New-Item -Name ZIP -Path $WorkFolderPath -ItemType Directory -Force -ErrorAction SilentlyContinue | Out-Null
                } CATCH {
                }
            }

            IF (Test-Path $ZIPfolderpath ) {
                foreach ($Sourcefile in $($sourceFiles.path)){
                    
                    $Obj        = $null
                    $fileStatus = $null

                    WV -prefix "FILENAME" -message $Sourcefile

                    TRY {
                        $destinationFile = join-path $WorkfolderPath $(($sourceFile.split("\"))[-1] -replace ".jar",".zip")
                        WV -prefix "COPY/RENAME" -message "[$sourceFile] to [$destinationFile]"
                        Copy-item -path $sourceFile -destination $destinationFile -Force -ErrorAction Stop
                    } CATCH {
                        WV -prefix "COPY/RENAME" -message "[$sourceFile] to [$destinationFile] [FAILED]"
                    }
                    TRY {
                        WV -prefix "EXPAND" -message "[$destinationFile] to folder [$ZIPFolderPath]"
                        Expand-Archive -Path $destinationFile -DestinationPath $ZIPFolderPath -Force -ErrorAction Stop
                    } CATCH {
                        WV -prefix "EXPAND" -message "[$destinationFile] to folder [$ZIPFolderPath] [FAILED]" 
                    }

                    IF ((Get-ChildItem $ZIPfolderpath -Recurse -File | Measure-Object | Select-Object -ExpandProperty count ) -gt 0) { 
                        TRY {
                            Get-ChildItem $ZIPfolderpath -Filter $JavaClass -Recurse | 
                                foreach {
                                    TRY {
                                        WV -prefix "REMOVING CLASS" -message "[$($_.FullName)] class [$javaclass]"
                                        Remove-Item -Path $_.fullname -force -Confirm:$false -ErrorAction stop
                                        $removeStatus = $true
                                    } CATCH {
                                        WV -prefix "REMOVING CLASS" -message "[$($_.FullName)] class [$javaclass] [FAILED]"
                                        $removeStatus = $true
                                    }
                                } # END Foreach
                        } CATCH {            
                        }

                        TRY {
                            $compress = @{
                                Path                = $ZipFolderPath
                                CompressionLevel    = $CompressionLevel
                                DestinationPath     = $destinationFile 
                            }
                            WV -prefix "COMPRESS" -message "[$ZipFolderPath] to [$destinationFile]"
                            Compress-Archive @compress -Force -ErrorAction stop
                            $compressStatus = $true
                        } CATCH {
                            WV -prefix "COMPRESS" -message "[$ZipFolderPath] to [$destinationFile] [FAILED]"
                            $compressStatus = $false
                        }

                        IF ($compressStatus) {
                            TRY {
                                WV -prefix "COPY/RENAME" -message "[$destinationFile] to [$sourceFile]"
                                Copy-item -path $destinationFile -destination $sourceFile -Force 
                            } CATCH {
                                WV -prefix "COPY/RENAME" -message "[$destinationFile] to [$sourceFile] [FAILED]"
                            }
                        }

                        TRY {
                            WV -prefix CLEANUP -message "removing folder [$workfolderPath]"
                            Remove-Item -Path $compress.Path -Recurse -Force -Confirm:$false -ErrorAction SilentlyContinue
                            $CleanUpStatus = "Successful"
                        } CATCH {
                            $CleanUpStatus = "Unsuccesful"
                        }

                        WV -prefix CLEANUP -message "status [$cleanUpStatus]"
                    }  # end IF (Get-childtem $workfolderpath)

                    ## TESTING IF ORGINAL FILE HAS BEEN "CLEANED"
                    TRY {
                        IF ([String]::isNullOrEmpty($(Select-String $Sourcefile -pattern $JavaClass  -ErrorAction SilentlyContinue))) {
                            WV -prefix "FILEMAME" -message "[$Sourcefile] status [CLEANED]"
                            $fileStatus = $true
                        } ELSE {
                            WV -prefix "FILEMAME" -message "[$Sourcefile] status [UNCLEANED]"
                            $fileStatus = $False
                        }
                    } CATCH {
                    }

                    IF ($out.IsPresent) {
                        $param = @{
                            ComputerName    = $env:COMPUTERNAME
                            FileName        = $(get-item -Path $Sourcefile -ErrorAction SilentlyContinue).Name
                            FullName        = $Sourcefile
                            Cleaned         = $fileStatus
                            QueryDate       = $(get-date)
                            Action          = "Clean"
                        }

                        New-Object -TypeName psobject -Property $param
                    } ELSE {
                        WV -prefix "OUTPUT" -message "not choosen"
                    }
                } # End Foreach ($sourcefile in)
            }
        } ELSEIF ((($sourceFiles | Measure-Object).count -gt 0) -and ($onlyQuery.IsPresent)) {
            IF ($out.IsPresent) {
                $param = @{
                    ComputerName    = $env:COMPUTERNAME
                    FileName        = $null
                    FullName        = $sourceFiles.path -join " | "
                    Cleaned         = $false
                    QueryDate       = $(get-date)
                    Action          = "onlyQeury"
                }
                New-Object -TypeName psobject -Property $param

            }
        }
        ELSE {
            IF ($out.IsPresent) {
                IF ($onlyQuery.IsPresent) {
                    $action = "onlyQuery"
                } Else {
                    $action = "Clean"
                }
                $param = @{
                    ComputerName    = $env:COMPUTERNAME
                    FileName        = $null
                    FullName        = $null  
                    Cleaned         = $true
                    QueryDate       = $(get-date)
                    Action          = $action
                }

                New-Object -TypeName psobject -Property $param
            } ELSE {
                WV -prefix $env:computername -message "non vulnerbal files found."
            }
        }
    }
    END {
    }
}
