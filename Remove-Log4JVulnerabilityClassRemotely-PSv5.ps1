Function Remove-Log4JVulnerabilityClassRemotely {
<#
    .SYNOPSIS
       CleanUp script for removing vulnerable Java class based on CVE-2021-45105

    .DESCRIPTION
        As the last resorse, the removing of the class file "JndiLookup.class" from the jar file containing it, can be necessary
        This script can find all files with JAR, WAR, EAR, JPI, and HPI extension or a single specified file with the vulnerability
        It can remove the string by unZipping it to a workfolder, and the reZip it back to its orginal location
        You can also choose just to get a list of files that contains the class with removing the class.

        The Script is running it paralle execution mode
       
    .PARAMETER Computername
        A single or collection of systems to perform the query against
       
    .PARAMETER Credential
        Credentials to query remote computers

    .PARAMETER ToCSV
        Name of CSV to write the results of the query to

    .PARAMETER Throttle
        Number of asynchronous jobs that will run at a time
           
    .PARAMETER ShowProgress
        Displays the progress of the services query
  
    .PARAMETER file
        fullname of a single file to investigate

    .PARAMETER JavaClass
        The class name to remove

    .PARAMETER WorkFolder
        The folder to where the work on the file is done
        Default: "temp-log4j"

    .PARAMETER RootPath
        The drive the workfolder is created on
        Default: "C:""

    .PARAMETER Compressionlevel
        What type of compression should be used
        Default: "Fastest"

    .PARAMETER Out
        To get the result of the cleanup out as an Object

    .PARAMETER onlyQuery
        If only interesting in getting the numbers, and fullnames on files vulnerable


    .NOTES
        Author:     Aksel Bork
        Created:    2021-12-22

        The RunSpace part is based on the article 
    
        Author:     Boe Prox
        Created:    2012-03-14
        link:       https://devblogs.microsoft.com/scripting/expert-commentary-2012-scripting-games-advanced-event-2/


        2021-12-22  1       Creation
        2021-12-22  1.1     Add extra extension to querystring ("*.jar","*.war","*.ear","*.jpi","*.hpi")
        2021-12-22  2       Change to use "RunSpace" for paralle execution
                            Adding "Write-infomation" for showing INPUT data and execution time
       

    .EXAMPLE
        Remove-Log4JVulnerabilityClassRemotely -Computername $env:COMPUTERNAME -Verbose -Credential $cred -InformationAction Continue

        Description
        -----------
        Cleanup all files found from the local system, and outputting verbose and information to console
        No output data would for futher processing would be made.
           

    .EXAMPLE
        $output = Remove-Log4JVulnerabilityClassRemotely -Computername fil01  -out -onlyQuery  -Credential $CRED -InformationAction Continue -Verbose   
        $output

        Description
        -----------
        Query all files found on local or remote computer, and outputting verbose and information to console
        Output data is stored in variable and pasted to the console.
        
       
        ####################################################################

        [INFO][INPUT][CREDENTIAL]          company\administrator
        [INFO][INPUT][COMPUTERS]           1
        [INFO][INPUT][FILE]                
        [INFO][INPUT][JAVACLASS]           JndiLookup.class
        [INFO][INPUT][WORKFOLDER]          _temp-log4J
        [INFO][INPUT][ROOTPATH]            C:
        [INFO][INPUT][COMPRESSION]         Fastest
        [INFO][INPUT][INCLUDENETWORKSHARE] False
        [INFO][INPUT][WRITE OUTPUT]        True
        [INFO][INPUT][ONLYQUERY]           True
        [INFO][INPUT][VERBOSE]             Continue
        [INFO][INPUT][CREDENTIAL]          company\administrator

        ####################################################################

        VERBOSE: 09:32:32.3518 [BEGIN  ] Creating runspace pool and session states
        VERBOSE: 09:32:32.3518 [BEGIN  ] Creating empty collection to hold runspace jobs
        VERBOSE: 09:32:32.3674 [PROCESS] Validating that current user is Administrator or supplied alternate credentials
        VERBOSE: 09:32:32.3719 [PROCESS] Adding fil01 collection
        VERBOSE: 09:32:32.3719 [PROCESS] Checking status of runspace jobs
        VERBOSE: 09:32:32.3835 [PROCESS] Finish processing the remaining runspace jobs: 
        VERBOSE: 09:32:33.3281 [BEGIN  ] [FIL01] Starting
        VERBOSE: 09:32:33.3281 [BEGIN  ] [FIL01][INPUT][FILE]                
        VERBOSE: 09:32:33.3281 [BEGIN  ] [FIL01][INPUT][FILE EXTENSION]      *.jar, *.war, *.ear, *.jpi, *.hpi
        VERBOSE: 09:32:33.3281 [BEGIN  ] [FIL01][INPUT][JAVACLASS]           JndiLookup.class
        VERBOSE: 09:32:33.3281 [BEGIN  ] [FIL01][INPUT][WORKFOLDER]          _temp-log4J
        VERBOSE: 09:32:33.3281 [BEGIN  ] [FIL01][INPUT][ROOTPATH]            C:
        VERBOSE: 09:32:33.3281 [BEGIN  ] [FIL01][INPUT][COMPRESSION]         Fastest
        VERBOSE: 09:32:33.3281 [BEGIN  ] [FIL01][INPUT][INCLUDENETWORKSHARE] False
        VERBOSE: 09:32:33.3281 [BEGIN  ] [FIL01][INPUT][WRITE OUTPUT]        True
        VERBOSE: 09:32:33.3281 [BEGIN  ] [FIL01][INPUT][ONLYQUERY]           True
        VERBOSE: 09:32:33.3281 [BEGIN  ] [FIL01][INPUT][VERBOSE]             True
        VERBOSE: 09:32:33.3437 [BEGIN  ] [FIL01][QUERING] Looking on [local] drives
        VERBOSE: 09:32:33.6562 [BEGIN  ] [FIL01][QUERING] Getting [local] drives
        VERBOSE: 09:32:33.6562 [BEGIN  ] [FIL01][QUERING][FILTERING] no smbmapped drives exits.. no filtering nessesary
        VERBOSE: 09:32:33.7031 [BEGIN  ] [FIL01][QUERING][DRIVE] C:\
        VERBOSE: 09:33:26.5313 [BEGIN  ] [FIL01][QUERING][DRIVE] S:\
        VERBOSE: 09:33:26.8750 [BEGIN  ] [FIL01][QUERING] files found [3]
        VERBOSE: 09:33:26.8906 [PROCESS] [FIL01] Status [UNCLEANED]
        VERBOSE: 09:33:26.8906 [END    ] [FIL01]  Ending 
        VERBOSE: 09:33:26.9657 [PROCESS] Closing the runspace pool
        VERBOSE: 09:33:26.9814 [PROCESS] Displaying Report

        ####################################################################
        [INFO][STARTTIME] 12/23/2021 09:32:32
        [INFO][ENDTIME]   12/23/2021 09:33:26
        [INFO][RUNTIME]   00d:00h:00m:54s
        ####################################################################
        
        Cleaned      : False
        FullName     : C:\_FILES\PAD.JavaBridge-2.jar | S:\Data\FILES\PAD.JavaBridge-2.jar | S:\Share\FILES\PAD.JavaBridge-2.jar
        StartDate    : 12/23/2021 9:24:24 AM
        IpAddress    : 10.0.2.201 | 10.0.0.201
        Action       : onlyQeury
        ComputerName : FIL01
        QueryDate    : 12/23/2021 9:25:18 AM

    .EXAMPLE
        $output = Remove-Log4JVulnerabilityClassRemotely -Computername fil01  -out  -Credential $CRED -InformationAction Continue -Verbose
        $output

        Description
        -----------
        Query all files found on alocal or remote computer, and outputting verbose and information to console
        If string is found in a file, it is "unZipped" and string remove to be "Zipped" again
        Output data is stored in variable and pasted to the console.


        VERBOSE: 10:14:24.0324 [BEGIN  ] Performing inital Administrator check
        VERBOSE: 10:14:24.0324 [BEGIN  ] Building hash table for ScriptBlock Parameters

        [INFO] Starting Remove-Log4JVulnerabilityClassRemotely

        ####################################################################

        [INFO][INPUT][CREDENTIAL]          company\administrator
        [INFO][INPUT][COMPUTERS]           1
        [INFO][INPUT][FILE]                
        [INFO][INPUT][JAVACLASS]           JndiLookup.class
        [INFO][INPUT][WORKFOLDER]          _temp-log4J
        [INFO][INPUT][ROOTPATH]            C:
        [INFO][INPUT][COMPRESSION]         Fastest
        [INFO][INPUT][INCLUDENETWORKSHARE] False
        [INFO][INPUT][WRITE OUTPUT]        True
        [INFO][INPUT][ONLYQUERY]           False
        [INFO][INPUT][VERBOSE]             Continue

        [INFO][INPUT][THROTTLE]            10
        [INFO][INPUT][TOCSV]               
        [INFO][INPUT][SHOWPROGRESS]        False

        ####################################################################

        VERBOSE: 10:14:24.0641 [BEGIN  ] Creating runspace pool and session states
        VERBOSE: 10:14:24.0908 [BEGIN  ] Creating empty collection to hold runspace jobs
        VERBOSE: 10:14:24.0958 [PROCESS] Validating that current user is Administrator or supplied alternate credentials
        VERBOSE: 10:14:24.0958 [PROCESS] Adding fil01 collection
        VERBOSE: 10:14:24.0958 [PROCESS] Checking status of runspace jobs
        VERBOSE: 10:14:24.1114 [PROCESS] Finish processing the remaining runspace jobs: 
        VERBOSE: 10:14:25.0834 [BEGIN  ] [FIL01] Starting
        VERBOSE: 10:14:25.0991 [BEGIN  ] [FIL01][INPUT][FILE]                
        VERBOSE: 10:14:25.0991 [BEGIN  ] [FIL01][INPUT][FILE EXTENSION]      *.jar, *.war, *.ear, *.jpi, *.hpi
        VERBOSE: 10:14:25.0991 [BEGIN  ] [FIL01][INPUT][JAVACLASS]           JndiLookup.class
        VERBOSE: 10:14:25.0991 [BEGIN  ] [FIL01][INPUT][WORKFOLDER]          _temp-log4J
        VERBOSE: 10:14:25.0991 [BEGIN  ] [FIL01][INPUT][ROOTPATH]            C:
        VERBOSE: 10:14:25.0991 [BEGIN  ] [FIL01][INPUT][COMPRESSION]         Fastest
        VERBOSE: 10:14:25.0991 [BEGIN  ] [FIL01][INPUT][INCLUDENETWORKSHARE] False
        VERBOSE: 10:14:25.0991 [BEGIN  ] [FIL01][INPUT][WRITE OUTPUT]        True
        VERBOSE: 10:14:25.0991 [BEGIN  ] [FIL01][INPUT][ONLYQUERY]           False
        VERBOSE: 10:14:25.0991 [BEGIN  ] [FIL01][INPUT][VERBOSE]             True
        VERBOSE: 10:14:25.1147 [BEGIN  ] [FIL01][QUERING] Looking on [local] drives
        VERBOSE: 10:14:25.4272 [BEGIN  ] [FIL01][QUERING] Getting [local] drives
        VERBOSE: 10:14:25.4428 [BEGIN  ] [FIL01][QUERING][FILTERING] no smbmapped drives exits.. no filtering nessesary
        VERBOSE: 10:14:25.4897 [BEGIN  ] [FIL01][QUERING][DRIVE] C:\
        VERBOSE: 10:15:18.3959 [BEGIN  ] [FIL01][QUERING][DRIVE] S:\
        VERBOSE: 10:15:18.7553 [BEGIN  ] [FIL01][QUERING] files found [1]
        VERBOSE: 10:15:18.7553 [PROCESS] [FIL01][DIRECTORY] creating work folder [C:\_temp-log4J]
        VERBOSE: 10:15:18.7553 [PROCESS] [FIL01][DIRECTORY] Creating folder [C:\_temp-log4J\ZIP]
        VERBOSE: 10:15:18.7553 [PROCESS] [FIL01][FILENAME] C:\_FILES\PAD.JavaBridge.jar
        VERBOSE: 10:15:18.7709 [PROCESS] [FIL01][COPY/RENAME] file [C:\_FILES\PAD.JavaBridge.jar] to [C:\_temp-log4J\PAD.JavaBridge.zip]
        VERBOSE: 10:15:18.7709 [PROCESS] [FIL01][EXPAND] file [C:\_temp-log4J\PAD.JavaBridge.zip] to folder [C:\_temp-log4J\ZIP]
        VERBOSE: 10:15:22.3803 [PROCESS] [FIL01][REMOVING CLASS][C:\_temp-log4J\ZIP\org\apache\logging\log4j\core\lookup\JndiLookup.class] class [JndiLookup.class]
        VERBOSE: 10:15:22.3803 [PROCESS] [FIL01][COMPRESS] file [C:\_temp-log4J\ZIP] to [C:\_temp-log4J\PAD.JavaBridge.zip]
        VERBOSE: 10:15:25.3334 [PROCESS] [FIL01][COPY/RENAME] file [C:\_temp-log4J\PAD.JavaBridge.zip] to [C:\_FILES\PAD.JavaBridge.jar]
        VERBOSE: 10:15:25.3334 [PROCESS] [FIL01][CLEANUP] Deleting folder [C:\_temp-log4J]
        VERBOSE: 10:15:25.5834 [PROCESS] [FIL01][CLEANUP] Status cleanup [Successful]
        VERBOSE: 10:15:25.6303 [PROCESS] [FIL01][FILENAME][C:\_FILES\PAD.JavaBridge.jar] Status [CLEANED]
        VERBOSE: 10:15:25.6459 [END    ] [FIL01]  Ending 
        VERBOSE: 10:15:25.7470 [PROCESS] Closing the runspace pool
        VERBOSE: 10:15:25.7470 [PROCESS] Displaying Report

        ####################################################################
        [INFO][STARTTIME] 12/23/2021 10:14:24
        [INFO][ENDTIME]   12/23/2021 10:15:25
        [INFO][RUNTIME]   00d:00h:01m:01s



        ComputerName : FIL01
        StartDate    : 12/23/2021 10:14:24 AM
        Action       : Clean
        FullName     : C:\_FILES\PAD.JavaBridge.jar
        Cleaned      : True
        FileName     : PAD.JavaBridge.jar
        IpAddress    : 10.0.2.201 | 10.0.0.201
        QueryDate    : 12/23/2021 10:15:25 AM



#>


#Requires -Version 5.0

    [cmdletbinding(
        DefaultParameterSetName = 'NonCSV'
    )]

    Param (
        [parameter(ValueFromPipeline = $True,ValueFromPipeLineByPropertyName = $True)]
        [Alias('CN','__Server')]
        [array]$Computername = $Env:Computername,

        #[parameter(mandatory=$true)]
        [System.Management.Automation.PSCredential]$Credential,

        [parameter(ParameterSetName = 'CSV')]
        [ValidateNotNullOrEmpty()]
        [String]$ToCSV,

        [parameter()]
        [int]$Throttle = 10,

        [parameter()]
        [switch]$ShowProgress,

        [string]$file, 

        [string]$JavaClass          = "JndiLookup.class",

        [string]$WorkFolder         = "_temp-log4J",

        [validatePattern("^[a-zA-Z]:$")]
        [string]$RootPath           = "C:",

        [ValidateSet("Optimal","NoCompression","Fastest")]
        [string]$CompressionLevel   = "Fastest", 

        [SWITCH]$includeNetworkShare,

        [SWITCH]$out,

        [SWITCH]$onlyQuery
    )

    Begin {
        $startTime = $(get-date)
        $old_VerbosePreference = $VerbosePreference 
        #region HELPERFUNCTIONS
        FUNCTION WV {
            Param (
                $prefix,
                $message
            )
            $time = Get-Date -f HH:mm:ss.ffff
            Write-Verbose "$time [$($prefix.padright(7,' '))] $message"
        }

        #Function that will be used to process runspace jobs
        Function Get-RunspaceData {

            [cmdletbinding()]

            param(

                [switch]$Wait,

                [switch]$ShowProgress

            )

            Do {

                $more = $false        

                Foreach($runspace in $runspaces) {

                    If ($runspace.Runspace.isCompleted) {

                        $Script:Report += $runspace.powershell.EndInvoke($runspace.Runspace) #|
                            #Select-Object value
                         #   Select SystemName,Name,State,StartMode,StartName

                        $runspace.powershell.dispose()

                        $runspace.Runspace = $null

                        $runspace.powershell = $null

                        $Script:i++ 

                        If ($PSBoundParameters['ShowProgress']) {

                            Write-Progress -Activity 'Services Query' -Status (“Processing Runspace: {0}” -f $runspace.computer) `

                            -PercentComplete (($i/$totalcount)*100)             

                        }                  

                    } ElseIf ($runspace.Runspace -ne $null) {

                        $more = $true

                    }

                }

                If ($more -AND $PSBoundParameters['Wait']) {

                    Start-Sleep -Milliseconds 100

                }  

                #Clean out unused runspace jobs

                $temphash = $runspaces.clone()

                $temphash | Where {

                    $_.runspace -eq $Null

                } | ForEach {

                    Write-Verbose (“Removing {0}” -f $_.computer)

                    $Runspaces.remove($_)

                }            

            } while ($more -AND $PSBoundParameters['Wait'])

        }

        #endregion 

        WV -prefix BEGIN -message “Performing inital Administrator check”
        $usercontext = [Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()
        $IsAdmin = $usercontext.IsInRole([Security.Principal.WindowsBuiltInRole] “Administrator”)    

          
        #####################################################################################
        WV -prefix BEGIN -message “Building hash table for ScriptBlock Parameters”

        IF (-NOT ($PSBoundParameters.Containskey("ComputerName"))) {
                [array]$computername = $env:COMPUTERNAME
            } 

        IF (-NOT ($PSBoundParameters.Containskey("file"))) {
            $file = $null
        } 

        IF (-NOT ($PSBoundParameters.Containskey("javaClass"))) {
            $javaClass = "JndiLookup.class"
        }

        IF (-NOT ($PSBoundParameters.Containskey("workfolder"))) {
            $WorkFolder = "_temp-log4J"
        }

        IF (-NOT ($PSBoundParameters.Containskey("RootPath"))) {
            $RootPath = "C:"
        }

        IF (-NOT ($PSBoundParameters.Containskey("Compressionlevel"))) {
            $CompressionLevel = "Fastest"
        }

        IF ($VerbosePreference -like "Continue") {
            $p_verbose = $true
        } Else {
            $p_verbose = $false
        }

        Write-Information -message ""
        Write-Information -message "[INFO] Starting $($myinvocation.MyCommand)"
        Write-Information -message ""
        Write-Information -message "####################################################################"
        Write-Information -message ""
        Write-Information -message "[INFO][INPUT][CREDENTIAL]          $($cred.UserName)"
        Write-Information -message "[INFO][INPUT][COMPUTERS]           $(IF ([string]::IsNullOrEmpty($computername)) {1} ELSE {($computername | Measure-Object).Count})"
        Write-Information -message "[INFO][INPUT][FILE]                $($file)"
        Write-Information -message "[INFO][INPUT][JAVACLASS]           $($JavaClass)"
        Write-Information -message "[INFO][INPUT][WORKFOLDER]          $($WorkFolder)"
        Write-Information -message "[INFO][INPUT][ROOTPATH]            $($RootPath)"
        Write-Information -message "[INFO][INPUT][COMPRESSION]         $($CompressionLevel)"
        Write-Information -message "[INFO][INPUT][INCLUDENETWORKSHARE] $($includeNetworkShare)"
        Write-Information -message "[INFO][INPUT][WRITE OUTPUT]        $($out)"
        Write-Information -message "[INFO][INPUT][ONLYQUERY]           $($onlyQuery)"
        Write-Information -message "[INFO][INPUT][VERBOSE]             $($VerbosePreference)"
        Write-Information -message ""
        Write-Information -message "[INFO][INPUT][THROTTLE]            $($Throttle)"
        Write-Information -message "[INFO][INPUT][TOCSV]               $($ToCSV)"
        Write-Information -message "[INFO][INPUT][SHOWPROGRESS]        $($ShowProgress)"
        Write-Information -message ""
        Write-Information -message "####################################################################"
        Write-Information -message ""

        ## CREATING PARAMETER VALUES FOR SCRIPTBLOCK
        $parameterHash = @{
            file                = $file #"test"#$null
            JavaClass           = $JavaClass #"JndiLookup.class"
            WorkFolder          = $WorkFolder#"_temp-log4J"
            RootPath            = $RootPath #"C:"
            CompressionLevel    = $CompressionLevel #"Fastest"
            includeNetworkShare = $includeNetworkShare #$false
            out                 = $out #$True
            onlyQuery           = $onlyQuery #$True
            UseVerbose          = $p_verbose #$True
            Credential          = $Credential
        }

        ## Supplied Alternate Credentials?
        If ($PSBoundParameters['Credential']) {
            $parameterHash.credential = $Credential
        }
     
        #####################################################################################
 
        #####################################################################################
        #Define Scriptblock for runspaces
        $scriptblock = {
            [cmdletbinding()]
            Param (    
                    $Computername,
                    $InputHash
            )

            BEGIN {
                #region HELPERFUNCTION
                FUNCTION WV {
                    Param (
                        $prefix,
                        $message
                    )
                    $time = Get-Date -f HH:mm:ss.ffff
                    Write-Verbose "$time [$($prefix.padright(7,' '))] $message"
                }

                FUNCTION Remove-Log4JVulnerabilityClass {
                    [cmdletbinding()]
                    Param (    
                        [parameter(Position=0)]
                        [string]$file,  # = "D:\ZIP\PAD.JavaBridge2.jar" ,

                        [parameter(Position=1)]
                        [string]$JavaClass          = "JndiLookup.class",

                        [parameter(Position=2)]
                        [string]$WorkFolder         = "_temp-log4J",

                        [parameter(Position=3)]
                        [validatePattern("^[a-zA-Z]:$")]
     
                        [string]$RootPath           = "C:",

                        [parameter(Position=4)]
                        [ValidateSet("Optimal","NoCompression","Fastest")]
                        [string]$CompressionLevel   = "Fastest", 

                        [parameter(Position=5)]
                        [SWITCH]$includeNetworkShare,

                        [parameter(Position=6)]
                        [SWITCH]$out,

                        [parameter(Position=7)]
                        [SWITCH]$onlyQuery,

                        [parameter(Position=8)]
                        [Switch]$UseVerbose
                    )
                    BEGIN {
                        #region HELPERFUNCTION                
                        FUNCTION WV {
                            Param (
                                $prefix,
                                $message
                            )
                            $time = Get-Date -f HH:mm:ss.ffff
                            Write-Verbose "$time [$($prefix.padright(7,' '))] $message"
                        }
                        #endregion HELPERFUNCTION

                        [array]$extension = "*.jar","*.war","*.ear","*.jpi","*.hpi"
                        $startTime = $(get-date)

                        $old_VerbosePreference = $VerbosePreference

                        $VerbosePreference = "silentlycontinue"
                         
                        ($IpAddress   = $((Get-NetIPAddress -PrefixOrigin Manual -ErrorAction SilentlyContinue).IPAddress) -join " | ") | Out-Null
                    
                        If ($useVerbose -eq $true) {
                            $VerbosePreference = "continue"
                        }

                        
                        WV -prefix BEGIN -message "[$($env:COMPUTERNAME)] Starting"
                        WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][INPUT][FILE]                $($file)"
                        WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][INPUT][FILE EXTENSION]      $($extension -join ", ")"
                        WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][INPUT][JAVACLASS]           $($JavaClass)"
                        WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][INPUT][WORKFOLDER]          $($WorkFolder)"
                        WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][INPUT][ROOTPATH]            $($RootPath)"
                        WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][INPUT][COMPRESSION]         $($CompressionLevel)"
                        WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][INPUT][INCLUDENETWORKSHARE] $($includeNetworkShare)"
                        WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][INPUT][WRITE OUTPUT]        $($out)"
                        WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][INPUT][ONLYQUERY]           $($onlyQuery)"
                        WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][INPUT][VERBOSE]             $($UseVerbose)"
                        

                        [array]$sourceFiles = $null
                        $WorkFolderPath     = Join-Path $RootPath $WorkFolder
                        $output             = $null

                        IF ((-NOT ($PSBoundParameters.ContainsKey('File'))) -or ([STRING]::IsNullOrEmpty($file))) {
                            ## FIND JAR-FILES 
                            IF ($includeNetworkShare.IsPresent) {
                                WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][QUERING] Looking on [all] drives"
                                $smbMapping = $null
                            } ELSE {
                                 WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][QUERING] Looking on [local] drives"
                                 TRY {
                                    $VerbosePreference = "silentlycontinue"
                                    ($smbMapping = Get-SmbMapping -ErrorAction SilentlyContinue) | Out-Null
                    
                                    If ($useVerbose -eq $true) {
                                        $VerbosePreference = "continue"
                                    }

                                } CATCH {
                                    WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][QUERING] Could not find any [MAPPED] drives"
                                    $smbMapping = $null
                                }
                            }
                            IF ($includeNetworkShare.IsPresent) {
                                WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][QUERING] Getting [all] drives"
                                $Drives = Get-PSDrive | Where-Object {($_.provider -like "*FileSystem*")}
                            } ELSE {
                                WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][QUERING] Getting [local] drives"
                                IF (-NOT [STRING]::IsNullOrEmpty($smbMapping)) {
                                    WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][QUERING][FILTERING] Removing smbmapped drives from query"
                                    $Drives = Get-PSDrive | Where-Object {(($_.provider -like "*FileSystem*") -and ($_.DisplayRoot -notin $smbMapping.remotepath))}
                                } ELSE {
                                    WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][QUERING][FILTERING] no smbmapped drives exits.. no filtering nessesary"
                                    $Drives = Get-PSDrive | Where-Object {$_.provider -like "*FileSystem*" }
                                }
                            }

                            $sourceFiles = $Drives | foreach {
                                WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][QUERING][DRIVE] $($_.root)"
                                Get-ChildItem $_.root -Recurse -include ($extension) -force -ErrorAction SilentlyContinue | foreach {
                                    TRY {
                                        Select-String $_ -pattern $JavaClass -ErrorAction Stop | Select-Object path -Unique -ErrorAction SilentlyContinue
                                    } CATCH {
                                    }
                                }
                            }

                        } ELSE {
                            WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][QUERING][FILE] $($file)"
                            TRY {
                                $sourceFile = get-item $file -ErrorAction Stop | Select-Object name,@{name='path';expression={$_.fullname}}
                            } CATCH {
                                WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][QUERING][FILE] $($file) - does not exists "
                            }
            
                           # $sourceFile.FullName
                            $sourceFiles = $sourceFile | foreach {
                                TRY {
                                    Select-String $_.path -pattern $JavaClass -ErrorAction Stop | Select-Object path -Unique -ErrorAction SilentlyContinue
                                } CATCH {
                                }
                            }
                        }
                        WV -prefix BEGIN -message "[$($env:COMPUTERNAME)][QUERING] files found [$($sourcefiles | measure-object | select-object -ExpandProperty count)]"
                    }
                    PROCESS {
                        ## REMOVE "JndiLookup" CLASS FROM JAR FILES AND COMPRESS THEM AGAIN
                        IF ((($sourceFiles | Measure-Object).count -gt 0) -and ($onlyQuery.IsPresent -eq $false)) { 
                            TRY {
                                WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][DIRECTORY] creating work folder [$WorkfolderPath]"
                                New-Item -Name $WorkFolder -path $($RootPath+"\") -ItemType Directory -Force -ErrorAction SilentlyContinue | Out-Null
                            } CATCH {
                                WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][DIRECTORY] creating work folder [$WorkfolderPath][FAILED]"
                            }

                            IF (Test-Path $WorkFolderPath ) {
                                $ZIPfolderPath = (Join-Path $WorkFolderPath ZIP)
                                TRY {
                                    WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][DIRECTORY] Creating folder [$ZipfolderPath]"
                                    New-Item -Name ZIP -Path $WorkFolderPath -ItemType Directory -Force -ErrorAction SilentlyContinue | Out-Null
                                } CATCH {
                                    WV -prefixPROCESS -message "[$($env:COMPUTERNAME)][DIRECTORY] Creating folder [$ZipfolderPath][FAILED]"
                                }
                            }

                            IF (Test-Path $ZIPfolderpath ) {
                                foreach ($Sourcefile in $($sourceFiles.path)){
                    
                                    $Obj        = $null
                                    $fileStatus = $null

                                    WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][FILENAME] $($sourcefile)"

                                    TRY {
                                        $destinationFile = join-path $WorkfolderPath ($(($sourceFile.split("\"))[-1].substring(0,($sourcefile.split("\"))[-1].lastindexof(".")))+".zip")
                                        WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][COPY/RENAME] file [$sourceFile] to [$destinationFile]"
                                        Copy-item -path $sourceFile -destination $destinationFile -Force -ErrorAction Stop
                                    } CATCH {
                                        WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][COPY/RENAME] file [$sourceFile] to [$destinationFile] [FAILED]"
                                    }
                                    TRY {
                                        WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][EXPAND] file [$destinationFile] to folder [$ZIPFolderPath]"
                                        
                                        $VerbosePreference = "silentlyContinue"
                                        Expand-Archive -Path $destinationFile -DestinationPath $ZIPFolderPath -Force -ErrorAction Stop | Out-Null
                                        If ($useVerbose -eq $true) {
                                            $VerbosePreference = "continue"
                                        }

                                    } CATCH {
                                        WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][EXPAND] file [$destinationFile] to folder [$ZIPFolderPath] [FAILED]" 
                                    }

                                    IF ((Get-ChildItem $ZIPfolderpath -Recurse -File | Measure-Object | Select-Object -ExpandProperty count ) -gt 0) { 
                                        TRY {
                                            Get-ChildItem $ZIPfolderpath -Filter $JavaClass -Recurse | 
                                                foreach {
                                                    TRY {
                                                        WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][REMOVING CLASS][$($_.FullName)] class [$javaclass]"
                                                        Remove-Item -Path $_.fullname -force -Confirm:$false -ErrorAction stop
                                                        $removeStatus = $true
                                                    } CATCH {
                                                         WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][REMOVING CLASS][$($_.FullName)] class [$javaclass] [FAILED]"
                                                        $removeStatus = $true
                                                    }
                                                } # END Foreach
                                        } CATCH {            
                                        }

                                        TRY {
                                            $compress = @{
                                                Path                = $ZipFolderPath
                                                CompressionLevel    = $CompressionLevel
                                                DestinationPath     = $destinationFile 
                                            }
                                            WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][COMPRESS] file [$ZipFolderPath] to [$destinationFile]"
                                            
                                            $VerbosePreference = "silentlyContinue"
                                            Compress-Archive @compress -Force -ErrorAction stop | Out-Null
                                            $compressStatus = $true
                                            
                                            If ($useVerbose -eq $true) {
                                                $VerbosePreference = "continue"
                                            }

                                        } CATCH {
                                            WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][COMPRESS] file [$ZipFolderPath] to [$destinationFile] [FAILED]"
                                            $compressStatus = $false
                                        }

                                        IF ($compressStatus) {
                                            TRY {
                                                WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][COPY/RENAME] file [$destinationFile] to [$sourceFile]"
                                                Copy-item -path $destinationFile -destination $sourceFile -Force 
                                            } CATCH {
                                                WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][COPY/RENAME] file [$destinationFile] to [$sourceFile] [FAILED]"
                                            }
                                        }

                                        TRY {
                                            WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][CLEANUP] Deleting folder [$workfolderPath]"
                                            Remove-Item -Path $workfolderPath -Recurse -Force -Confirm:$false -ErrorAction SilentlyContinue
                                            $CleanUpStatus = "Successful"
                                        } CATCH {
                                            $CleanUpStatus = "Unsuccesful"
                                        }

                                        WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][CLEANUP] Status cleanup [$cleanUpStatus]"
                                    }  # end IF (Get-childtem $workfolderpath)

                                    ## TESTING IF ORGINAL FILE HAS BEEN "CLEANED"
                                    TRY {
                                        IF ([String]::isNullOrEmpty($(Select-String $Sourcefile -pattern $JavaClass  -ErrorAction SilentlyContinue))) {
                                            WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][FILENAME][$Sourcefile] Status [CLEANED]"
                                            $fileStatus = $true
                                        } ELSE {
                                            WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][FILENAME][$Sourcefile] Status [UNCLEANED]"
                                            $fileStatus = $False
                                        }
                                    } CATCH {
                                    }

                                    IF ($out.IsPresent) {
                                        $param = @{
                                            ComputerName    = $env:COMPUTERNAME
                                            FileName        = $(get-item -Path $Sourcefile -ErrorAction SilentlyContinue).Name
                                            FullName        = $Sourcefile
                                            Cleaned         = $fileStatus
                                            QueryDate       = $(get-date)
                                            StartDate       = $startTime
                                            Action          = "Clean"
                                            IpAddress       = $IpAddress
                                        }

                                        New-Object -TypeName psobject -Property $param
                                    } ELSE {
                                        WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][OUTPUT] Not choosen"
                                    }
                                } # End Foreach ($sourcefile in)
                            }
                        } ELSEIF ((($sourceFiles | Measure-Object).count -gt 0) -and ($onlyQuery.IsPresent)) {
                            WV -prefix PROCESS -message "[$($env:COMPUTERNAME)] Status [UNCLEANED]"
                            IF ($out.IsPresent) {
                                $param = @{
                                    ComputerName    = $env:COMPUTERNAME
                                   # FileName        = $(get-item -Path $(Sourcefile) -ErrorAction SilentlyContinue).Name
                                    FullName        = $sourceFiles.path -join " | "
                                    Cleaned         = $false
                                    QueryDate       = $(get-date)
                                    StartDate       = $startTime
                                    Action          = "onlyQeury"
                                    IpAddress       = $IpAddress
                                }
                           
                               #$Sourcefiles

                                New-Object -TypeName psobject -Property $param
                        
                            } ELSE {
                                WV -prefix PROCESS -message "[$($env:COMPUTERNAME)][OUTPUT] Not choosen"
                            }
                        } ELSE {
                            IF ($out.IsPresent) {
                                IF ($onlyQuery.IsPresent) {
                                    $action = "onlyQuery"
                                } Else {
                                    $action = "Clean"
                                }
                                IF (-NOT [STRING]::IsNullOrEmpty($file)) {
                                    $s_file = $file
                                    $s_filename = ($file.Split("\"))[-1]
                                } ELSE {
                                    $s_file = $null
                                    $s_filename = $null
                                }

                                $param = @{
                                    ComputerName    = $env:COMPUTERNAME
                                    FileName        = $s_filename
                                    FullName        = $s_file  
                                    Cleaned         = $true
                                    QueryDate       = $(get-date)
                                    StartDate       = $startTime
                                    Action          = $action
                                    IpAddress       = $IpAddress
                                }

                                New-Object -TypeName psobject -Property $param
                            } ELSE {
                                WV -prefix PROCESS -message "[$($env:COMPUTERNAME)] Non vulnerbal files found."
                            }
                        }
                    }
                    END {
                        WV -prefix END  "[$($env:COMPUTERNAME)]  Ending $($myinvocation.MyCommand)"
                        $VerbosePreference = $old_VerbosePreference
                    }
                } # END FUNCTION

                #endregion HELPERFUNCTION
             
                $file = $InputHash.file
                $JavaClass = $InputHash.javaclass
                $WorkFolder = $InputHash.Workfolder
                $RootPath = $InputHash.RootPath
                $CompressionLevel = $InputHash.CompressionLevel
                [switch]$includeNetworkShare = $inputHask.includeNetworkShare
                [switch]$out = $InputHash.out
                [switch]$onlyQuery = $InputHash.onlyQuery
                [switch]$useVerbose = $InputHash.useVerbose
                $credential = $inputhash.credential

                $startTime = $(get-date)

            }
            PROCESS {
                Foreach ($computer in $computerName) {
                    IF ($computer -like $env:COMPUTERNAME) {
                        WV -prefix PROCESS -message "[COMPUTER][LOCAL] $($computer)"
                
                        $param = $null
                        $param = @{
                            file                = $file
                            JavaClass           = $JavaClass
                            WorkFolder          = $WorkFolder
                            RootPath            = $RootPath
                            CompressionLevel    = $CompressionLevel
                            includeNetworkShare = $includeNetworkShare
                            out                 = $out
                            onlyQuery           = $onlyQuery
                            useVerbose          = $useVerbose #$p_verbose
                        }

                        Remove-Log4JVulnerabilityClass @param

                    } ELSE {
                        WV -prefix PROCESS -message "[COMPUTER][REMOTE] $($computer)"
                        
                        IF (Test-WSMan -ComputerName $computer -ErrorAction SilentlyContinue) {
                            WV -prefix PROCESS -message "[COMPUTER][REMOTE][$($computer)] Accessable status [TRUE]"
                      
                            Invoke-Command -ComputerName $computer -ScriptBlock ${function:Remove-Log4JVulnerabilityClass} -ArgumentList $file, $JavaClass, $WorkFolder,$RootPath,$CompressionLevel,$includeNetworkShare,$out,$onlyQuery,$useVerbose -HideComputerName -Credential $credential | 
                                Select-Object * -ExcludeProperty PSComputerName,RunspaceId  

                        } ELSE {
                            WV -prefix PROCESS -message "[COMPUTER][REMOTE][$($computer)] Accessable stats [FALSE]"
                        }
                    }
                }

            }
            END {
                WV -prefix END -message ""
                WV -prefix END -message "Ending $($myinvocation.MyCommand)"
                WV -prefix END -message ""

                $endTime = $(get-date)
                $timeSpawn = New-TimeSpan -Start $startTime -End $endTime

                WV -prefix END -message "####################################################################"
                WV -prefix END -message "[STARTTIME] $($startTime)"
                WV -prefix END -message "[ENDTIME]   $($EndTime)"
                WV -prefix END -message "[RUNTIME]   $("{0:dd}d:{0:hh}h:{0:mm}m:{0:ss}s" -f $($timeSpawn))"
                WV -prefix END -message "####################################################################"
            }
        }

        #####################################################################################
        
        
        #Counter for Write-Progress
        $Script:i = 0     

        #Main collection to hold all data returned from runspace jobs
        $Script:report = @()   

        #Define hash table for Get-RunspaceData function
        $runspacehash = @{}

        If ($PSBoundParameters['ShowProgress']) {
            $runspacehash.ShowProgress = $True
        }

        WV -prefix BEGIN -message “Creating runspace pool and session states”

        $sessionstate = [system.management.automation.runspaces.initialsessionstate]::CreateDefault()
        $runspacepool = [runspacefactory]::CreateRunspacePool(1, $Throttle, $sessionstate, $Host)
        $runspacepool.Open() 

        WV -prefix BEGIN -message “Creating empty collection to hold runspace jobs”

        $Script:runspaces = New-Object System.Collections.ArrayList
        $totalcount = $computername.count

    }
    Process {       

        WV -prefix PROCESS -message “Validating that current user is Administrator or supplied alternate credentials”

        If (-Not ($Computername.count -eq 1 -AND $Computername[0] -eq $Env:Computername)) {
            #Now check that user is either an Administrator or supplied Alternate Credentials
            If (-Not ($IsAdmin -OR $PSBoundParameters['Credential'])) {
                Write-Warning (“You must be an Administrator to perform this action against remote systems!”)
                Break
            }
        }

        ForEach ($Computer in $Computername) {
           #Create the powershell instance and supply the scriptblock with the other parameters
           $powershell = [powershell]::Create().AddScript($ScriptBlock).AddArgument($computer).AddArgument($parameterHash)

           #Add the runspace into the powershell instance
           $powershell.RunspacePool = $runspacepool

           #Create a temporary collection for each runspace
           $temp = “” | Select-Object PowerShell,Runspace,Computer
           $Temp.Computer = $Computer
           $temp.PowerShell = $powershell

          

           #Save the handle output when calling BeginInvoke() that will be used later to end the runspace

           $temp.Runspace = $powershell.BeginInvoke()

           WV -prefix PROCESS -message “Adding $($temp.Computer) collection”
           $runspaces.Add($temp) | Out-Null

           WV -prefix PROCESS -message “Checking status of runspace jobs”
           Get-RunspaceData @runspacehash -Verbose:$false
        }                        
    }

    End {                    
        WV -prefix PROCESS -message “Finish processing the remaining runspace jobs: "#$(($runspaces | Where {$_.Runspace -ne $Null}).Count)”
        $runspacehash.Wait = $true

        Get-RunspaceData @runspacehash -Verbose:$false

        WV -prefix PROCESS -message “Closing the runspace pool”
        $runspacepool.close()       

        If ($PSBoundParameters['ShowProgress']) {
            #Close the Write-Progress bar so it does not affect the displaying of data when completed.       
            Write-Progress -Activity 'Services Query' -Status 'Completed' -Completed           
        }

        If ($PSBoundParameters['ToCSV']) {
            WV -prefix PROCESS -message “Writing report to CSV: $($ToCSV)"

            $Report | Export-Csv -Path $ToCSV -NoTypeInformation
        } Else {
            WV -prefix PROCESS -message “Displaying Report”

            Write-Output $Report
        }

        $endTime = $(get-date)
        $timeSpawn = New-TimeSpan -Start $startTime -End $endTime

        Write-Information -message ""
        Write-Information -message "####################################################################"
        Write-Information -message "[INFO][STARTTIME] $($startTime)"
        Write-Information -message "[INFO][ENDTIME]   $($EndTime)"
        Write-Information -message "[INFO][RUNTIME]   $("{0:dd}d:{0:hh}h:{0:mm}m:{0:ss}s" -f $($timeSpawn))"
        Write-Information -message "####################################################################"
        Write-Information -message ""
    }
}
